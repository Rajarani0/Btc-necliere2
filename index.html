<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC Nuclear SMC Signal Bot</title>
    <script src="https://cdn.jsdelivr.net/npm/node-fetch@2.6.1/browser.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; background: #1a1a1a; color: #fff; padding: 20px; }
        #status { background: #333; padding: 10px; border-radius: 5px; margin: 10px 0; }
        .signal { background: #4CAF50; padding: 15px; border-radius: 5px; margin: 10px 0; display: none; }
        .error { background: #f44336; }
        input { width: 100%; padding: 10px; margin: 5px 0; border: none; border-radius: 5px; }
        button { background: #2196F3; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; }
        #logs { background: #000; color: #0f0; padding: 10px; height: 300px; overflow-y: scroll; font-family: monospace; }
    </style>
</head>
<body>
    <h1>BTC Nuclear SMC Signal Bot (HTML Version)</h1>
    <p>Upload this to GitHub Pages for 24/7 running. Signals will auto-send to your Telegram bot and channel.</p>
    
    <label>Telegram Bot Token:</label>
    <input type="text" id="token" placeholder="e.g., 8344115140:AAEiUx-CpLV_QTN1N0I7zWWZZBEiM6AAW5Y">
    
    <label>Chat IDs (comma-separated, e.g., your personal ID and channel like 123456789,-1001234567890):</label>
    <input type="text" id="chatids" placeholder="1349670684",-1003440275053">
    
    <button onclick="startBot()">Start Bot</button>
    <button onclick="stopBot()">Stop Bot</button>
    
    <div id="status">Status: Stopped</div>
    <div id="logs"></div>
    <div id="signal" class="signal"></div>

    <script>
        // =================== CONFIG ===================
        const SYMBOL = "BTCUSDT";
        const SCAN_INTERVAL_MS = 60 * 1000; // 1 min
        const MINUTES_15_LIMIT = 500;
        const H1_LIMIT = 300;
        const H4_LIMIT = 200;
        const VOLUME_SPIKE_MULT = 2.5;
        const MIN_SIGNAL_GAP = 60 * 60 * 1000; // 1 hour
        const OB_IMBALANCE_THRESHOLD = 0.60;
        // ============================================================

        let lastSignalTime = 0;
        let intervalId = null;
        let isRunning = false;

        function log(msg) {
            const logs = document.getElementById('logs');
            logs.innerHTML += new Date().toLocaleString() + ': ' + msg + '\n';
            logs.scrollTop = logs.scrollHeight;
        }

        function updateStatus(msg, isError = false) {
            const status = document.getElementById('status');
            status.textContent = 'Status: ' + msg;
            status.className = isError ? 'error' : '';
        }

        async function sendTelegram(msgHtml) {
            const token = document.getElementById('token').value;
            if (!token || token.includes('PUT_YOUR')) {
                log('Telegram token not set. Skipping send.');
                return;
            }
            const chatIdsStr = document.getElementById('chatids').value;
            const chatIds = chatIdsStr.split(',').map(id => id.trim());
            for (const id of chatIds) {
                const url = `https://api.telegram.org/bot${token}/sendMessage?chat_id=${id}&text=${encodeURIComponent(msgHtml)}&parse_mode=HTML&disable_web_page_preview=true`;
                try {
                    const res = await fetch(url);
                    const json = await res.json();
                    if (!json.ok) log('TG send failed: ' + JSON.stringify(json));
                    else log('Sent to ' + id);
                    await sleep(250);
                } catch (e) {
                    log('TG error: ' + e.message);
                }
            }
        }

        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

        // Fetch klines (using fetch)
        async function klines(interval, limit = 500) {
            const url = `https://api.binance.com/api/v3/klines?symbol=${SYMBOL}&interval=${interval}&limit=${limit}`;
            try {
                const r = await fetch(url);
                const j = await r.json();
                return j.map(c => ({ t: c[0], o: +c[1], h: +c[2], l: +c[3], c: +c[4], v: +c[5] }));
            } catch (e) {
                log('Klines fetch error: ' + e.message);
                return [];
            }
        }

        // ATR
        function ATR(candles, period = 14) {
            if (candles.length < period + 1) return 0;
            const trs = [];
            for (let i = 1; i < candles.length; i++) {
                const cur = candles[i];
                const prev = candles[i - 1];
                const tr = Math.max(cur.h - cur.l, Math.abs(cur.h - prev.c), Math.abs(cur.l - prev.c));
                trs.push(tr);
            }
            let atr = trs.slice(0, period).reduce((a, b) => a + b, 0) / period;
            for (let i = period; i < trs.length; i++) {
                atr = (atr * (period - 1) + trs[i]) / period;
            }
            return atr;
        }

        // Order Blocks (simple)
        function detectOrderBlocks(candles) {
            let bull = null, bear = null;
            for (let i = 5; i < candles.length - 2; i++) {
                const p = candles[i - 1], n = candles[i];
                if (p.c < p.o && n.c > n.o && n.c > p.h && n.l <= p.l) {
                    bull = { price: p.l, index: i - 1 };
                }
                if (p.c > p.o && n.c < n.o && n.c < p.l && n.h >= p.h) {
                    bear = { price: p.h, index: i - 1 };
                }
            }
            return { bull, bear };
        }

        // FVG
        function detectFVG(candles) {
            for (let i = 2; i < candles.length; i++) {
                const a = candles[i - 2], x = candles[i];
                if (a.h < x.l) return 'bull';
                if (a.l > x.h) return 'bear';
            }
            return null;
        }

        // Volume Spike
        function isVolumeSpike(candles, multiplier = VOLUME_SPIKE_MULT) {
            if (candles.length < 3) return false;
            const last = candles[candles.length - 1].v;
            const prev = candles[candles.length - 2].v;
            const avgLast5 = candles.slice(-6, -1).reduce((s, c) => s + c.v, 0) / 5 || prev;
            return last > Math.max(prev * multiplier, avgLast5 * multiplier);
        }

        // Orderbook Imbalance
        async function orderbookImbalance(limit = 20) {
            try {
                const url = `https://api.binance.com/api/v3/depth?symbol=${SYMBOL}&limit=100`;
                const r = await fetch(url);
                const j = await r.json();
                const bids = j.bids.slice(0, limit).reduce((s, b) => s + (parseFloat(b[0]) * parseFloat(b[1])), 0);
                const asks = j.asks.slice(0, limit).reduce((s, a) => s + (parseFloat(a[0]) * parseFloat(a[1])), 0);
                const total = bids + asks;
                if (total === 0) return 0.5;
                return bids / total;
            } catch (e) {
                log('OB error: ' + e.message);
                return 0.5;
            }
        }

        // 4h Bias
        function trendBiasFrom4h(h4Candles) {
            const closes = h4Candles.map(c => c.c);
            const sma20 = closes.slice(-21, -1).reduce((a, b) => a + b, 0) / 20;
            const last = closes[closes.length - 1];
            if (last > sma20) return 'bull';
            if (last < sma20) return 'bear';
            return 'neutral';
        }

        function fmt(n) { return Number(n).toFixed(0); }

        // Main Scan
        async function scan() {
            try {
                const [m15, h1, h4] = await Promise.all([
                    klines('15m', MINUTES_15_LIMIT),
                    klines('1h', H1_LIMIT),
                    klines('4h', H4_LIMIT)
                ]);

                if (m15.length === 0) {
                    log('No data fetched');
                    return;
                }

                const price = m15[m15.length - 1].c;
                const atr_1h = ATR(h1, 14);
                const atr_15m = ATR(m15, 14);
                const ob15 = detectOrderBlocks(m15);
                const ob1h = detectOrderBlocks(h1);
                const fvg15 = detectFVG(m15.slice(-30));
                const volSpike = isVolumeSpike(m15);
                const bias4h = trendBiasFrom4h(h4);
                const obImb = await orderbookImbalance(30);

                log(`Price: ${fmt(price)}, 4hBias: ${bias4h}, OBimb: ${obImb.toFixed(2)}`);

                const canLong = ob15.bull && ob1h.bull && fvg15 === 'bull' && volSpike && obImb > OB_IMBALANCE_THRESHOLD && bias4h !== 'bear';
                const canShort = ob15.bear && ob1h.bear && fvg15 === 'bear' && volSpike && obImb < (1 - OB_IMBALANCE_THRESHOLD) && bias4h !== 'bull';

                if (Date.now() - lastSignalTime < MIN_SIGNAL_GAP) {
                    if (canLong || canShort) log('Signal blocked by minGap');
                    return;
                }

                if (canLong || canShort) {
                    const entry = price;
                    const slBuffer = Math.max(atr_15m * 1.2, 30);
                    let sl, tp, rr = 4.5;
                    if (canLong) {
                        sl = Math.max(ob15.bull.price - slBuffer, entry - 1000);
                        tp = Math.round(entry + (entry - sl) * rr);
                    } else {
                        sl = Math.min(ob15.bear.price + slBuffer, entry + 1000);
                        tp = Math.round(entry - (sl - entry) * rr);
                    }

                    const msg = `<b>SMC PRO SIGNAL</b>\n${canLong ? "üî• <b>NUCLEAR LONG</b>" : "‚ùÑÔ∏è <b>NUCLEAR SHORT</b>"}\n\n` +
                        `Symbol: <b>${SYMBOL}</b>\nEntry: <b>$${fmt(entry)}</b>\nSL: <b>$${fmt(sl)}</b>\nTP: <b>$${fmt(tp)}</b>\nRR: <b>1:${rr}</b>\n\n` +
                        `Setup: OB(15m+1h) + FVG + Volume Spike + Orderbook Filter + 4hBias(${bias4h})\n` +
                        `Price Time: ${new Date().toLocaleString()}\n\n<i>Note: This is signal only. Manage position sizing & risk.</i>`;

                    await sendTelegram(msg);
                    lastSignalTime = Date.now();
                    log(`Signal sent: ${canLong ? 'LONG' : 'SHORT'} Entry ${fmt(entry)} TP ${fmt(tp)} SL ${fmt(sl)}`);

                    // Show signal on page
                    document.getElementById('signal').innerHTML = msg.replace(/\n/g, '<br>');
                    document.getElementById('signal').style.display = 'block';
                }
            } catch (e) {
                log('SCAN ERROR: ' + e.message);
            }
        }

        function startBot() {
            if (isRunning) return;
            isRunning = true;
            updateStatus('Running...');
            scan();
            intervalId = setInterval(scan, SCAN_INTERVAL_MS);
            log('Bot started');
        }

        function stopBot() {
            if (intervalId) clearInterval(intervalId);
            isRunning = false;
            updateStatus('Stopped');
            log('Bot stopped');
        }

        // Auto-start if on GitHub Pages (optional)
        if (location.hostname === 'yourusername.github.io') {
            document.getElementById('token').value = 'YOUR_TOKEN_HERE'; // Pre-fill if needed
            document.getElementById('chatids').value = 'YOUR_ID_HERE,-100YOUR_CHANNEL_ID';
            setTimeout(startBot, 2000);
        }
    </script>
</body>
</html>